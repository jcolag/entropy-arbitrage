---
layout: post
title: ...And Don't Call Me SSHirley
date: 2025-08-06 07:21:04-0400
categories:
tags: [linux, tech-tips]
summary: Dealing with too many SSH keys
thumbnail: /blog/assets/5593143750_3efd7eba2b_o.png
offset: -30%
description: Half a solution to the too-many-attempts problem when you don't remember making any attempts.
spell: SSHirley linux Forgejo IdentitiesOnly HostName PreferredAuthentications PubkeyAuthentication IdentityFile
proofed: true
---

* Ignore for ToC
{:toc}

This post should go quickly enough.

In moving onto the "new" laptop, as painstakingly chronicled in recent [developer diary](/blog/tag/dev-journal) posts, I set up a couple of old computers---two older Raspberry Pi units, in particular---as servers.  They include a couple of services, such as [Forgejo](https://forgejo.org/), some of which caused me to deploy some new SSH keys after importing my old batch.

![A ring of rings of old keys lying on a blanket](/blog/assets/5593143750_3efd7eba2b_o.png "Weirdly, I actually own a bunch of blankets with that look from some old surplus shopping...")

And apparently, when you have too many SSH keys---and by "too many," I apparently mean *seven*---then all Hell breaks loose, where the libraries will try to throw *all the keys* at everything that you interact with, until the remote site complains that you have definitely tried to overload it.  If you happen to need one of the keys chosen early, you can get in.  If you need a later key, or if *you don't expect to log in with a key at all*, then you get bounced with "too many attempts."  Surely, they can't expect us to work like this...

## An Incomplete Solution

Bluntness first, I don't think that I actually *solved* this problem, only mitigated it.  A full solution would involve every login associated with its key, if any, and then not interfere with any other connection.

It doesn't sound like we can get that, though.

Instead, we get to create a file and hope that we caught every case.

## Configuration

OK, technically, we have *two* options.  For one option, you manually tell `git` and `ssh` and whatever else might use these keys which key to use, including none at all, in every action.

```console
ssh -i ~/.ssh/some-key -o IdentitiesOnly=yes me@the-server.local
```

Right, no problems, there.  And as my parents used to say when overloaded, maybe I can shove a broom up [REDACTED], and sweep the floor as I go, too.

For the slightly less egregious plan, we have a configuration file.  In `~/.ssh/config`, you need entries that usually look like one of these two samples.

```
Host server
  HostName whatever-server.local
  PreferredAuthentications password
  PubkeyAuthentication no
  User me

Host local-forgejo
  HostName whatever-server.local
  IdentitiesOnly yes
  IdentityFile ~/.ssh/local-forgejo
  User git
```

Lather, rinse, and repeat for GitHub, GitLab, Codeberg, a bunch of Forgejo instances, Source Hut, a bunch of shell-based logins, and probably more as you go on.  Maybe of interest, you don't need to restart anything to see the changes, so you can go through everything one at a time, and even fine-tune entries as you go.  At least for me, though, the entries all follow one form or the other, both taking a host and user.  One says to only ever use the password for that user@host, and the other indicates the key to use.

Then, go everywhere that you list a server-and-host pair, for example your `.git/config` files in repositories, and change the server name to whatever you called it in `Host`.  The "too many attempts" message can guide you to finding these, if they don't come immediately to mind.  Regardless, this process, if you need it, also lets you distinguish between multiple logins on the same server by assigning them separate names---even tab-completion, at least on my machine with no added work---if that makes your life any easier.

Note that this does mean knowing in advance anywhere that you might want to log in using the SSH infrastructure.  Every server where you have an account, and every account on that server, if you don't supply a key or specify not to use a key, you'll get bounced out of the attempt.

## Secret Third Option

Yeah, OK, you could also reuse the same key everywhere you go.  You only spread around the public key, so that seems like less of a disaster waiting to happen than reusing passwords, but it definitely *feels* unpleasant.

And sure, if somebody compromises your computer or your backups, then they have access to everything through your single key.  But that probably holds true even if you use hundreds of keys, because I'd bet that you don't set a pass-phrase on your keys.  It does, after all, feel unspeakably backward to set up password-less login somewhere, only to set a password that you need every time you use it...

## Nothing Else

I honestly almost didn't post this, barely a post by my usual standards.  However, two things changed my mind.

First, I'll probably need to go through this again at some point, and at heart, the [tech tips](/blog/tag/tech-tips) posts exist at least partly, and maybe even primarily, to make sure that I have someplace to look for things when "I know that I did it before."

Also, though, it took me long enough to cobble together a working solution that maybe this will save somebody else some effort in the future.

And with that, good luck...

* * *

**Credits**:  The header image is [Lockless keys](https://www.flickr.com/photos/13434526@N00/5593143750) by [plenty.r.](https://www.flickr.com/photos/plenty/), made available under the terms of the [Creative Commons Attribution Share-Alike 2.0 Generic](https://creativecommons.org/licenses/by-sa/2.0/deed.en) license.
